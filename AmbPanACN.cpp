//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// NOTE by default, chuginate generates a new UGen subclass in this file
//      but it is possible, of course, to create non-UGen classes in a chugin!
// To modify this generated file for a non-UGen class...
//      1. in QUERY->begin_class(), change "UGen" to a different ChucK class
//         (e.g., `QUERY->begin_class(QUERY, "AmbPanACN", "Object");`)
//      2. remove or commment out the line containing QUERY->add_ugen_func()
//      3. that's it; the rest is no different for UGens/non-UGens
//-----------------------------------------------------------------------------
// NOTE once you have built this into a chugin (AmbPanACN.chug), here are a few
//      helpful tools for testing / probing / verifying your new chugin!
//
// chuginate also generated a AmbPanACN-test.ck boilerplate ChucK program
//      to help test your chugin (see AmbPanACN-test.ck for more instructions)
//
// run `chuck --chugin-probe` to probe what chugins would be loaded, and
//      from where in the chugin search paths
//
// run `chuck -v3 --loop` to see what chugins are actually loaded at runtime,
//      with more info and error reporting than with --chugin-probe
//
// other helpful chugin-related flags include:
//      --chugin:<filename>
//      --chugin-path:(path) / -G(path)
//      --chugin-load:{on/off}
//
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------

// include chugin header
#include "chugin.h"

// general includes
#include <stdio.h>
#include <iostream>
// #include <math.h>
#include <cmath>

// constants
const int MAX_CHANNELS = 64;

// static variables
static t_CKUINT amb_bounds_normalized = 0;
static t_CKUINT amb_bounds_radians = 1;

// declaration of chugin constructor
CK_DLL_CTOR( ambpanacn_ctor );
CK_DLL_CTOR( ambpanacn_ctor_order );
CK_DLL_CTOR( ambpanacn_ctor_orderAndPeriod );
CK_DLL_CTOR( ambpanacn_ctor_orderAndPeriodAndBounds );

// declaration of chugin desctructor
CK_DLL_DTOR( ambpanacn_dtor );

// declaration of ZAmbPan functions
CK_DLL_MFUN( ambpanacn_path );

// declaration of setters
CK_DLL_MFUN( ambpanacn_setAzimuth );
CK_DLL_MFUN( ambpanacn_setElevation );
CK_DLL_MFUN( ambpanacn_setAzimuthVelocity );
CK_DLL_MFUN( ambpanacn_setElevationVelocity );
CK_DLL_MFUN( ambpanacn_setVelocities );
CK_DLL_MFUN( ambpanacn_pan );
CK_DLL_MFUN( ambpanacn_set );
CK_DLL_MFUN( ambpanacn_setUpdatePeriod );
CK_DLL_MFUN( ambpanacn_setOrder );

// declaration of getters
CK_DLL_MFUN( ambpanacn_getAzimuth );
CK_DLL_MFUN( ambpanacn_getElevation );
CK_DLL_MFUN( ambpanacn_getAzimuthVelocity );
CK_DLL_MFUN( ambpanacn_getElevationVelocity );
CK_DLL_MFUN( ambpanacn_getOrder );
CK_DLL_MFUN( ambpanacn_getOutChannels );
CK_DLL_MFUN( ambpanacn_getUpdatePeriod );

// for chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICKF( ambpanacn_tickf );

// this is a special offset reserved for chugin internal data
t_CKINT ambpanacn_data_offset = 0;

//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class AmbPanACN
{
public:
    // constructor
    AmbPanACN( t_CKFLOAT fs, t_CKINT order, t_CKDUR update_period, t_CKINT bounds_type )
    {
        m_order = order;
        m_out_channels = (order+1) * (order+1);
        m_azimuth = 0;
        m_elevation = 0;
        m_azi_velocity = 0;
        m_ele_velocity = 0;
        m_pan_change = true;
        srate = fs;
        m_path = false;
        m_path_samples_left = -1;
        m_bounds_type = bounds_type;

        // Gain interpolation
        m_update_period = (update_period < 1 ? 1 : update_period);
        m_samples_left = 0;

        for (int c = 0; c < MAX_CHANNELS; c++) {
            m_gain_cur[c] = 0;
            m_gain_next[c] = 0;
            m_gain_step[c] = 0;
        }

        // Initial calculation for coefficients + gains
        compute_coeffs();
        compute_gains();

        // Initialize starting gains
        for (int c = 0; c < MAX_CHANNELS; c++)
        {
            m_gain_cur[c] = m_gain_next[c];
        }
    }

    // for chugins extending UGen
    void tick( SAMPLE * in, SAMPLE * out, int nframes )
    {
        for (int f = 0; f < nframes; f++) {
            // compute new gains only if updatePeriod samples have passed and azimuth and/or elevation has changed
            // if (m_samples_left <= 0)
            if (m_samples_left <= 0 && (m_pan_change || m_path || m_azi_velocity != 0 || m_ele_velocity != 0)) {
                m_azimuth += m_azi_velocity;
                m_elevation += m_ele_velocity;
                if (m_pan_change) m_path_samples_left = 0;
                // Update gains based on new azimuth / elevation
                compute_gains();
                m_samples_left = m_update_period;
                m_pan_change = false;
                m_path = false;
            }

            if (m_path_samples_left >= 0) {
                m_path_samples_left--;
                if (m_path_samples_left < 0) {
                    m_path = false;
                    m_azi_velocity = 0;
                    m_ele_velocity = 0;
                }
                // std::cout << m_path_samples_left << '\t' << m_azimuth << '\t' << m_elevation << '\n';
            }

            // Write only active channels
            for(int c = 0; c < m_out_channels; c++)
            {
                out[(f * MAX_CHANNELS) + c] = m_gain_cur[c] * in[f];
            }

            // Zero out the rest
            for(int c = m_out_channels; c < MAX_CHANNELS; c++)
            {
                out[(f * MAX_CHANNELS) + c] = 0.;
            }

            if (m_samples_left > 0) {
                // Advance gains toward target
                for (int c = 0; c < m_out_channels; c++) {
                    m_gain_cur[c] += m_gain_step[c];
                }

                // Decrement sample counter
                m_samples_left--;

                // Stop exactly at target
                if (m_samples_left == 0)
                {
                    for (int c = 0; c < m_out_channels; ++c)
                    {
                        m_gain_cur[c] = m_gain_next[c];
                        m_gain_step[c] = 0;
                    }
                }
            }
        }
    }

    void path(t_CKFLOAT init_a, t_CKFLOAT init_e, t_CKFLOAT final_a, t_CKFLOAT final_e, t_CKDUR path_time) {
        path_time = path_time <= m_update_period ? m_update_period: path_time;
        path_time += fmod(m_update_period - path_time, m_update_period);

        m_azi_velocity = (final_a - init_a) / path_time * m_update_period;
        m_ele_velocity = (final_e - init_e) / path_time * m_update_period;
        m_azimuth = init_a - m_azi_velocity;
        m_elevation = init_e - m_ele_velocity;

        m_pan_change = false;
        m_path = true;
        m_path_samples_left = path_time;
    }

    // setters
    t_CKFLOAT setAzimuth( t_CKFLOAT a )
    {
        // Scale [-1, 1] to [-PI, PI]
        if (m_bounds_type == amb_bounds_normalized) {
            a = scalef(a, -1.0, 1., -1 * M_PI, M_PI);
        }

        if (a != m_azimuth)
        {
            m_azimuth = a - m_azi_velocity;
            m_pan_change = true;
        }
        return m_azimuth;
    }

    t_CKFLOAT setElevation( t_CKFLOAT e )
    {
        // Scale [-1, 1] to [-PI, PI]
        if (m_bounds_type == amb_bounds_normalized) {
            e = scalef(e, -1.0, 1., -1 * M_PI, M_PI);
        }

        if (e != m_elevation)
        {
            m_elevation = e - m_ele_velocity;
            m_pan_change = true;
        }
        return m_elevation;
    }

    t_CKFLOAT setAzimuthVelocity( t_CKFLOAT a )
    {
        a *= m_update_period / srate;
        if (a != m_azi_velocity)
        {
            m_azi_velocity = a;
        }
        m_path_samples_left = -1;
        return m_azi_velocity;
    }

    t_CKFLOAT setElevationVelocity( t_CKFLOAT e )
    {
        e *= m_update_period / srate;
        if (e != m_ele_velocity)
        {
            m_ele_velocity = e;
        }
        m_path_samples_left = -1;
        return m_ele_velocity;
    }

    t_CKVEC2 setVelocities( t_CKFLOAT a, t_CKFLOAT e )
    {
        m_azi_velocity = a * m_update_period / srate;
        m_ele_velocity = e * m_update_period / srate;

        // Return a vector with azimuth and elevation
        t_CKVEC2 retVec;
        retVec.x = m_azi_velocity;
        retVec.y = m_ele_velocity;
        return retVec;
    }

    t_CKVEC2 pan( t_CKFLOAT a, t_CKFLOAT e)
    {
        // Scale [-1, 1] to [-PI, PI]
        if (m_bounds_type == amb_bounds_normalized) {
            a = scalef(a, -1.0, 1., -1 * M_PI, M_PI);
            e = scalef(e, -1.0, 1., -1 * M_PI, M_PI);
        }

        m_azimuth = a - m_azi_velocity;
        m_elevation = e - m_ele_velocity;
        m_pan_change = true;

        // Return a vector with azimuth and elevation
        t_CKVEC2 retVec;
        retVec.x = m_azimuth;
        retVec.y = m_elevation;
        return retVec;
    }

    t_CKVEC4 set( t_CKFLOAT a, t_CKFLOAT e, t_CKFLOAT a_v, t_CKFLOAT e_v)
    {
        // Scale [-1, 1] to [-PI, PI]
        if (m_bounds_type == amb_bounds_normalized) {
            a = scalef(a, -1.0, 1., -1 * M_PI, M_PI);
            e = scalef(e, -1.0, 1., -1 * M_PI, M_PI);
        }

        m_azi_velocity = a_v * m_update_period / srate;
        m_ele_velocity = e_v * m_update_period / srate;
        m_azimuth = a - m_azi_velocity;
        m_elevation = e - m_ele_velocity;

        // Return a vector with azimuth and elevation
        t_CKVEC4 retVec;
        retVec.w = m_azimuth;
        retVec.x = m_elevation;
        retVec.y = m_azi_velocity;
        retVec.z = m_ele_velocity;
        return retVec;
    }

    t_CKINT setUpdatePeriod( t_CKDUR p )
    {
        p = (p < 1 ? 1 : p);
        m_azi_velocity *= p / m_update_period;
        m_ele_velocity *= p / m_update_period;
        m_path_samples_left *= p / m_update_period;
        m_update_period = p;
        m_samples_left = 0;
        return m_update_period;
    }

    t_CKINT setOrder( t_CKINT order )
    {
        m_order = order;
        m_out_channels = (order+1) * (order+1);
        return order;
    }

    // getters
    t_CKFLOAT getAzimuth()
    {
        return m_azimuth;
    }

    t_CKFLOAT getElevation()
    {
        return m_elevation;
    }

    t_CKFLOAT getAzimuthVelocity()
    {
        return m_azi_velocity / m_update_period * srate;
    }

    t_CKFLOAT getElevationVelocity()
    {
        return m_ele_velocity / m_update_period * srate;
    }

    t_CKINT getOrder()
    {
        return m_order;
    }

    t_CKINT getOutChannels()
    {
        return m_out_channels;
    }

    t_CKDUR getUpdatePeriod()
    {
        return m_update_period;
    }

private:

    void compute_coeffs() {
        // Run only once and store values
        // 1st order - 4 channels
        m_coeffs[0] = 1.;
        m_coeffs[1] = 1.;
        m_coeffs[2] = 1.;
        m_coeffs[3] = 1.;

        // 2nd order - 9 channels
        m_coeffs[4] = sqrt(3);
        m_coeffs[5] = (1. / 4.) * sqrt(3);
        m_coeffs[6] = (3. / 2.);
        m_coeffs[7] = (1. / 4.) * sqrt(3);
        m_coeffs[8] = (1. / 2.) * sqrt(3);

        // 3rd order - 16 channels
        m_coeffs[9] = (1. / 4.) * sqrt(10);
        m_coeffs[10] = sqrt(15);
        m_coeffs[11] = (1. / 4.) * sqrt(6);
        m_coeffs[12] = (1. / 2.);
        m_coeffs[13] = (1. / 4.) * sqrt(6);
        m_coeffs[14] = (1. / 2.) * sqrt(15);
        m_coeffs[15] = (1. / 4.) * sqrt(10);

        // 4th order - 25 channels
        m_coeffs[16] = (1. / 32.) * sqrt(35);
        m_coeffs[17] = (1. / 4.) * sqrt(70);
        m_coeffs[18] = (1. / 2.) * sqrt(5);
        m_coeffs[19] = (1. / 4.) * sqrt(10);
        m_coeffs[20] = (35. / 8.);
        m_coeffs[21] = (1. / 4.) * sqrt(10);
        m_coeffs[22] = (1. / 4.) * sqrt(5);
        m_coeffs[23] = (1. / 4.) * sqrt(70);
        m_coeffs[24] = sqrt(35);

        // 5th order - 36 channels
        m_coeffs[25] = (3. / 16.) * sqrt(14);
        m_coeffs[26] = (3. / 64.) * sqrt(35);
        m_coeffs[27] = (-1. / 16.) * sqrt(70);
        m_coeffs[28] = (1. / 2.) * sqrt(105);
        m_coeffs[29] = (1. / 8.) * sqrt(15);
        m_coeffs[30] = (1. / 8.);
        m_coeffs[31] = (1. / 8.) * sqrt(15);
        m_coeffs[32] = (1. / 4.) * sqrt(105);
        m_coeffs[33] = (-1. / 16.) * sqrt(70);
        m_coeffs[34] = (3. / 8.) * sqrt(35);
        m_coeffs[35] = (3. / 128.) * sqrt(14);

        // 6th order - 49 channels
        m_coeffs[36] = (1. / 16.) * sqrt(462);
        m_coeffs[37] = (3. / 16.) * sqrt(154);
        m_coeffs[38] = (3. / 256.) * sqrt(7);
        m_coeffs[39] = (-1. / 16.) * sqrt(210);
        m_coeffs[40] = (1. / 16.) * sqrt(210);
        m_coeffs[41] = (1. / 8.) * sqrt(21);
        m_coeffs[42] = (231. / 16.);
        m_coeffs[43] = (1. / 8.);
        m_coeffs[44] = (1. / 32.) * sqrt(210);
        m_coeffs[45] = (-1. / 16.) * sqrt(210);
        m_coeffs[46] = (3. / 16.) * sqrt(7);
        m_coeffs[47] = (3. / 256.) * sqrt(154);
        m_coeffs[48] = (1. / 256.) * sqrt(462);

        // 7th order - 64 channels
        m_coeffs[49] = (1. / 32.) * sqrt(429);
        m_coeffs[50] = (1. / 512.) * sqrt(6006);
        m_coeffs[51] = (1. / 32.) * sqrt(231);
        m_coeffs[52] = (1. / 512.) * sqrt(231);
        m_coeffs[53] = (-1. / 32.) * sqrt(21);
        m_coeffs[54] = (1. / 16.) * sqrt(42);
        m_coeffs[55] = (1. / 32.) * sqrt(7);
        m_coeffs[56] = (1. / 16.);
        m_coeffs[57] = (1. / 32.) * sqrt(7);
        m_coeffs[58] = (1. / 32.) * sqrt(42);
        m_coeffs[59] = (-1. / 32.) * sqrt(21);
        m_coeffs[60] = (1. / 16.) * sqrt(231);
        m_coeffs[61] = (1. / 32.) * sqrt(231);
        m_coeffs[62] = (1. / 512.) * sqrt(6006);
        m_coeffs[63] = (1. / 32.) * sqrt(429);
    }

    void compute_gains()
    {
        // Azimuth repeated expressions
        t_CKFLOAT sinA = sinf(m_azimuth);
        t_CKFLOAT cosA = cosf(m_azimuth);

        t_CKFLOAT sinA2 = sinA * sinA;
        t_CKFLOAT sinA4 = sinA2 * sinA2;
        t_CKFLOAT sinA6 = sinA4 * sinA2;

        t_CKFLOAT cosA2 = cosA * cosA;
        t_CKFLOAT cosA4 = cosA2 * cosA2;
        t_CKFLOAT cosA6 = cosA4 * cosA2;

        t_CKFLOAT sin2A = 2 * sinA * cosA;
        t_CKFLOAT cos2A = (cosA * cosA) - (sinA * sinA);

        t_CKFLOAT sin3A = 2 * cosA * sin2A - sinA;
        t_CKFLOAT cos3A = 2 * cosA * cos2A - cosA;

        t_CKFLOAT sin4A = 2 * cosA * sin3A - sin2A;
        t_CKFLOAT cos4A = 2 * cosA * cos3A - cos2A;

        t_CKFLOAT sin5A = 2 * cosA * sin4A - sin3A;
        t_CKFLOAT cos5A = 2 * cosA * cos4A - cos3A;

        t_CKFLOAT sin6A = 2 * cosA * sin5A - sin4A;
        t_CKFLOAT cos6A = 2 * cosA * cos5A - cos4A;

        // Elevation repeated expressions
        t_CKFLOAT sinE = sinf(m_elevation);
        t_CKFLOAT cosE = cosf(m_elevation);

        t_CKFLOAT sinE2 = sinE * sinE;
        t_CKFLOAT sinE4 = sinE2 * sinE2;
        t_CKFLOAT sinE6 = sinE4 * sinE2;

        t_CKFLOAT cosE2 = cosE * cosE;
        t_CKFLOAT cosE3 = cosE2 * cosE;
        t_CKFLOAT cosE4 = cosE2 * cosE2;
        t_CKFLOAT cosE6 = cosE4 * cosE2;
        t_CKFLOAT cosE7 = cosE6 * cosE;

        t_CKFLOAT sin2E = 2 * sinE * cosE;
        t_CKFLOAT cos2E = (cosE * cosE) - (sinE * sinE);

        t_CKFLOAT sin3E = 2 * cosE * sin2E - sinE;
        t_CKFLOAT cos3E = 2 * cosE * cos2E - cosE;

        t_CKFLOAT cos2E_12 = (cos2E + 1) * (cos2E + 1);
        t_CKFLOAT cos2E_13 = cos2E_12 * (cos2E + 1);

        // Calculate ACN Equations with SN3D normalization
        // 1st order - 4 channels
        if (m_order >= 1) {
            m_gain_next[0] = 1.;
            m_gain_next[1] = sinA * cosE;
            m_gain_next[2] = sinE;
            m_gain_next[3] = cosE * cosA;
        }

        // 2nd order - 9 channels
        if (m_order >= 2) {
            m_gain_next[4] = m_coeffs[4] * sinA * cosE2 * cosA;
            m_gain_next[5] = m_coeffs[5] * 2 * sin2E * sinA;
            m_gain_next[6] = m_coeffs[6] * sinE2 - 0.5;
            m_gain_next[7] = m_coeffs[7] * 2 * sin2E * cosA;
            m_gain_next[8] = m_coeffs[8] * cosE2 * cos2A;
        }

        // 3rd order - 16 channels
        if (m_order >= 3) {
            m_gain_next[9]  = m_coeffs[9]  * (3 - 4 * sinA2) * sinA * cosE3;
            m_gain_next[10] = m_coeffs[10] * sinE * sinA * cosE2 * cosA;
            m_gain_next[11] = m_coeffs[11] * (5 * sinE2 - 1) * sinA * cosE;
            m_gain_next[12] = m_coeffs[12] * (5 * sinE2 - 3) * sinE;
            m_gain_next[13] = m_coeffs[13] * (5 * sinE2 - 1) * cosE * cosA;
            m_gain_next[14] = m_coeffs[14] * sinE * cosE2 * cos2A;
            m_gain_next[15] = m_coeffs[15] * (1 - 4 * sinA2) * cosE3 * cosA;
        }

        // 4th order - 25 channels
        if (m_order >= 4) {
            m_gain_next[16] = m_coeffs[16] * cos2E_12 * sin4A;
            m_gain_next[17] = m_coeffs[17] * (3 - 4 * sinA2) * sinE * sinA * cosE3;
            m_gain_next[18] = m_coeffs[18] * (7 * sinE2 - 1) * sinA * cosE2 * cosA;
            m_gain_next[19] = m_coeffs[19] * (7 * sinE2 - 3) * sinE * sinA * cosE;
            m_gain_next[20] = m_coeffs[20] * sinE4 - 3.75 * sinE2 + 0.375;
            m_gain_next[21] = m_coeffs[21] * (7 * sinE2 - 3) * sinE * cosE * cosA;
            m_gain_next[22] = m_coeffs[22] * (7 * sinE2 - 1) * cosE2 * cos2A;
            m_gain_next[23] = m_coeffs[23] * (1 - 4 * sinA2) * sinE * cosE3 * cosA;
            m_gain_next[24] = m_coeffs[24] * (sinA4 - sinA2 + 0.125) * cosE4;
        }

        // 5th order - 36 channels
        if (m_order >= 5) {
            m_gain_next[25] = m_coeffs[25] * (16 * sinA4 - 20 * sinA2 + 5) * sinA * cosE3;
            m_gain_next[26] = m_coeffs[26] * cos2E_12 * 2 * sinE * sin4A;
            m_gain_next[27] = m_coeffs[27] * (9 * sinE2 - 1) * (4 * sinA2 - 3) * sinA * cosE3;
            m_gain_next[28] = m_coeffs[28] * (3 * sinE2 - 1) * sinE * sinA * cosE2 * cosA;
            m_gain_next[29] = m_coeffs[29] * (21 * sinE4 - 14 * sinE2 + 1) * sinA * cosE;
            m_gain_next[30] = m_coeffs[30] * (63 * sinE4 - 70 * sinE2 + 15) * sinE;
            m_gain_next[31] = m_coeffs[31] * (21 * sinE4 - 14 * sinE2 + 1) * cosE * cosA;
            m_gain_next[32] = m_coeffs[32] * (3 * sinE2 - 1) * sinE * cosE2 * cos2A;
            m_gain_next[33] = m_coeffs[33] * (9 * sinE2 - 1) * (4 * sinA2 - 1) * cosE3 * cosA;
            m_gain_next[34] = m_coeffs[34] * (8 * sinA4 - 8 * sinA2 + 1) * sinE * cosE4;
            m_gain_next[35] = m_coeffs[35] * cos2E_12 * 2 * cosE * cos5A;
        }

        // 6th order - 49 channels
        if (m_order >= 6) {
            m_gain_next[36] = m_coeffs[36] * (16 * sinA4 - 16 * sinA2 + 3) * sinA * cosE6 * cosA;
            m_gain_next[37] = m_coeffs[37] * (16 * sinA4 - 20 * sinA2 + 5) * sinE * sinA * cosE3;
            m_gain_next[38] = m_coeffs[38] * cos2E_12 * sin4A * (18 - 22 * cos2E);
            m_gain_next[39] = m_coeffs[39] * (11 * sinE2 - 3) * (4 * sinA2 - 3) * sinE * sinA * cosE3;
            m_gain_next[40] = m_coeffs[40] * (33 * sinE4 - 18 * sinE2 + 1) * sinA * cosE2 * cosA;
            m_gain_next[41] = m_coeffs[41] * (33 * sinE4 - 30 * sinE2 + 5) * sinE * sinA * cosE;
            m_gain_next[42] = m_coeffs[42] * sinE6 - 19.6875 * sinE4 + 6.5625 * sinE2 - 0.3125;
            m_gain_next[43] = m_coeffs[43] * 4.58257569496 * (33 * sinE4 - 30 * sinE2 + 5) * sinE * cosE * cosA;
            m_gain_next[44] = m_coeffs[44] * (33 * sinE4 - 18 * sinE2 + 1) * cosE2 * cos2A;
            m_gain_next[45] = m_coeffs[45] * (11 * sinE2 - 3) * (4 * sinA2 - 1) * sinE * cosE3 * cosA;
            m_gain_next[46] = m_coeffs[46] * (11 * sinE2 - 1) * (8 * sinA4 - 8 * sinA2 + 1) * cosE4;
            m_gain_next[47] = m_coeffs[47] * 2 * sin2E * cos5A * cos2E_12;
            m_gain_next[48] = m_coeffs[48] * cos2E_13 * cos6A;
        }

        // 7th order - 64 channels
        if (m_order >= 7) {
            m_gain_next[49] = m_coeffs[49] * (-57 * sinA6 + 91 * sinA4 - 35 * sinA2 + 7 * cosA6) * sinA * cosE7;
            m_gain_next[50] = m_coeffs[50] * cos2E_13 * (2 * sinE * sin6A);
            m_gain_next[51] = m_coeffs[51] * (13 * sinE2 - 1) * (16 * sinA4 - 20 * sinA2 + 5) * sinA * cosE3;
            m_gain_next[52] = m_coeffs[52] * cos2E_12 * sin4A * (54 * sinE - 26 * sin3E);
            m_gain_next[53] = m_coeffs[53] * (4 * sinA2 - 3) * (143 * sinE4 - 66 * sinE2 + 3) * sinA * cosE3;
            m_gain_next[54] = m_coeffs[54] * (143 * sinE4 - 110 * sinE2 + 15) * sinE * sinA * cosE2 * cosA;
            m_gain_next[55] = m_coeffs[55] * (429 * sinE6 - 495 * sinE4 + 135 * sinE2 - 5) * sinA * cosE;
            m_gain_next[56] = m_coeffs[56] * (429 * sinE6 - 693 * sinE4 + 315 * sinE2 - 35) * sinE;
            m_gain_next[57] = m_coeffs[57] * (429 * sinE6 - 495 * sinE4 + 135 * sinE2 - 5) * cosE * cosA;
            m_gain_next[58] = m_coeffs[58] * (143 * sinE4 - 110 * sinE2 + 15) * sinE * cosE2 * cos2A;
            m_gain_next[59] = m_coeffs[59] * (4 * sinA2 - 1) * (143 * sinE4 - 66 * sinE2 + 3) * cosE3 * cosA;
            m_gain_next[60] = m_coeffs[60] * (13 * sinE2 - 3) * (8 * sinA4 - 8 * sinA2 + 1) * sinE * cosE4;
            m_gain_next[61] = m_coeffs[61] * (13 * sinE2 - 1) * (16 * sinA4 - 12 * sinA2 + 1) * cosE3 * cosA;
            m_gain_next[62] = m_coeffs[62] * (2 * sinE * cos6A) * cos2E_13;
            m_gain_next[63] = m_coeffs[63] * (-63 * sinA6 + 77 * sinA4 - 21 * sinA2 + cosA6) * cosE7 * cosA;
        }
    }

    // Helper functions
    float scalef(float x, float in_min, float in_max, float out_min, float out_max)
    {
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    }

    // instance data
    t_CKINT m_order;
    t_CKINT m_out_channels;
    t_CKDUR m_update_period;
    t_CKINT m_samples_left;
    t_CKINT m_pan_change;
    t_CKINT m_path;
    t_CKDUR m_path_samples_left;
    t_CKINT m_bounds_type;

    t_CKFLOAT m_azimuth;
    t_CKFLOAT m_elevation;
    t_CKFLOAT m_azi_velocity;
    t_CKFLOAT m_ele_velocity;
    t_CKFLOAT srate;

    t_CKFLOAT m_coeffs[MAX_CHANNELS];
    t_CKFLOAT m_gain_next[MAX_CHANNELS];
    t_CKFLOAT m_gain_cur[MAX_CHANNELS];
    t_CKFLOAT m_gain_step[MAX_CHANNELS];
};

//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO( AmbPanACN )
{
    // the version string of this chugin, e.g., "v1.2.1"
    QUERY->setinfo( QUERY, CHUGIN_INFO_CHUGIN_VERSION, "v0.1.0" );
    // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
    QUERY->setinfo( QUERY, CHUGIN_INFO_AUTHORS, "Zac Dulkin & Gregg Oliva" );
    // text description of this chugin; what is it? what does it do? who is it for?
    QUERY->setinfo( QUERY, CHUGIN_INFO_DESCRIPTION, "Ambisonics Panner up to 7th Order" );
    // (optional) URL of the homepage for this chugin
    QUERY->setinfo( QUERY, CHUGIN_INFO_URL, "https://github.com/gloliva/AmbPanACN/tree/master" );
    // (optional) contact email
    QUERY->setinfo( QUERY, CHUGIN_INFO_EMAIL, "" );
}


//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY( AmbPanACN )
{
    // generally, don't change this...
    QUERY->setname( QUERY, "AmbPanACN" );

    // ------------------------------------------------------------------------
    // begin class definition(s); will be compiled, verified,
    // and added to the chuck host type system for use
    // ------------------------------------------------------------------------
    // NOTE to create a non-UGen class, change the second argument
    // to extend a different ChucK class (e.g., "Object")
    QUERY->begin_class( QUERY, "AmbPanACN", "UGen" );

    // set up doc handling
    QUERY->doc_class( QUERY, "ACN ambisonics panner. Supports up to 7th order." );

    // register default constructor
    QUERY->add_ctor( QUERY, ambpanacn_ctor );
    QUERY->doc_func( QUERY, "Default constructor. Defaults to 3rd order and a 64 sample update period" );

    QUERY->add_ctor( QUERY, ambpanacn_ctor_order );
    QUERY->add_arg( QUERY, "int", "order" );
    QUERY->doc_func( QUERY, "Constructor that takes in the ambisonics order" );

    QUERY->add_ctor( QUERY, ambpanacn_ctor_orderAndPeriod );
    QUERY->add_arg( QUERY, "int", "order" );
    QUERY->add_arg( QUERY, "int", "updatePeriod" );
    QUERY->doc_func( QUERY, "Constructor that takes in the ambisonics order and updatePeriod" );

    QUERY->add_ctor( QUERY, ambpanacn_ctor_orderAndPeriodAndBounds );
    QUERY->add_arg( QUERY, "int", "order" );
    QUERY->add_arg( QUERY, "int", "updatePeriod" );
    QUERY->add_arg( QUERY, "int", "boundsType" );
    QUERY->doc_func( QUERY, "Constructor that takes in the ambisonics order, updatePeriod, and boundsType" );

    // register the destructor (probably no need to change)
    QUERY->add_dtor( QUERY, ambpanacn_dtor );

    // for UGens only: add tick function
    // NOTE a non-UGen class should remove or comment out this next line
    QUERY->add_ugen_funcf( QUERY, ambpanacn_tickf, NULL, 1, MAX_CHANNELS );
    // NOTE: if this is to be a UGen with more than 1 channel,
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    QUERY->add_mfun( QUERY, ambpanacn_path, "void", "path" );
    QUERY->add_arg( QUERY, "float", "init_a" );
    QUERY->add_arg( QUERY, "float", "init_e" );
    QUERY->add_arg( QUERY, "float", "final_a" );
    QUERY->add_arg( QUERY, "float", "final_e" );
    QUERY->add_arg( QUERY, "dur", "path_time" );

    QUERY->doc_func( QUERY, "Set velocity of horizontal / vertical angles of point source" );

    // setters
    QUERY->add_mfun( QUERY, ambpanacn_setAzimuth, "float", "azimuth" );
    QUERY->add_arg( QUERY, "float", "a" );
    QUERY->doc_func( QUERY, "Set horizontal angle of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_setElevation, "float", "elevation" );
    QUERY->add_arg( QUERY, "float", "e" );
    QUERY->doc_func( QUERY, "Set vertical angle of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_setAzimuthVelocity, "float", "azi_velocity" );
    QUERY->add_arg( QUERY, "float", "a" );
    QUERY->doc_func( QUERY, "Set velocity of horizontal angle of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_setElevationVelocity, "float", "ele_velocity" );
    QUERY->add_arg( QUERY, "float", "e" );
    QUERY->doc_func( QUERY, "Set velocity of vertical angle of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_setVelocities, "float", "set_velocities" );
    QUERY->add_arg( QUERY, "float", "a" );
    QUERY->add_arg( QUERY, "float", "e" );
    QUERY->doc_func( QUERY, "Set velocity of horizontal / vertical angles of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_pan, "vec2", "pan" );
    QUERY->add_arg( QUERY, "float", "a" );
    QUERY->add_arg( QUERY, "float", "e" );
    QUERY->doc_func( QUERY, "Set both vertical and horizontal angle of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_set, "vec4", "set" );
    QUERY->add_arg( QUERY, "float", "a" );
    QUERY->add_arg( QUERY, "float", "e" );
    QUERY->add_arg( QUERY, "float", "a_v" );
    QUERY->add_arg( QUERY, "float", "e_v" );
    QUERY->doc_func( QUERY, "Set vertical and horizontal angle and velocities of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_setOrder, "int", "order" );
    QUERY->add_arg( QUERY, "int", "o" );
    QUERY->doc_func( QUERY, "Set ambisonics order" );

    QUERY->add_mfun( QUERY, ambpanacn_setUpdatePeriod, "int", "updatePeriod" );
    QUERY->add_arg( QUERY, "int", "p" );
    QUERY->doc_func( QUERY, "Set the number of samples for gain interpolation. A value of 1 means the values will be recomputed every sample" );

    // getters
    QUERY->add_mfun( QUERY, ambpanacn_getAzimuth, "float", "azimuth" );
    QUERY->doc_func( QUERY, "Get horizontal angle of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_getElevation, "float", "elevation" );
    QUERY->doc_func( QUERY, "Get vertical angle of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_getAzimuthVelocity, "float", "azi_velocity" );
    QUERY->doc_func( QUERY, "Get velocity of horizontal angle of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_getElevationVelocity, "float", "ele_velocity" );
    QUERY->doc_func( QUERY, "Get velocity of vertical angle of point source" );

    QUERY->add_mfun( QUERY, ambpanacn_getOrder, "int", "order" );
    QUERY->doc_func( QUERY, "Get ambisonics order" );

    QUERY->add_mfun( QUERY, ambpanacn_getOutChannels, "int", "outChannels" );
    QUERY->doc_func( QUERY, "Get number of channels needed for the order (e.g. 3rd order returns 16)" );

    QUERY->add_mfun( QUERY, ambpanacn_getUpdatePeriod, "int", "updatePeriod" );
    QUERY->doc_func( QUERY, "Get the number of samples between recomputing gain values" );

    // Static variables
    QUERY->add_svar( QUERY, "int", "NORMALIZED", true, (void *)&amb_bounds_normalized);
    QUERY->add_svar( QUERY, "int", "RADIANS", true, (void *)&amb_bounds_radians);

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    ambpanacn_data_offset = QUERY->add_mvar( QUERY, "int", "@apacn_data", false );

    // ------------------------------------------------------------------------
    // end the class definition
    // IMPORTANT: this MUST be called to each class definition!
    // ------------------------------------------------------------------------
    QUERY->end_class( QUERY );

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the default constructor
CK_DLL_CTOR( ambpanacn_ctor )
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT( SELF, ambpanacn_data_offset ) = 0;

    // instantiate our internal c++ class representation
    AmbPanACN * apacn_obj = new AmbPanACN( API->vm->srate(VM), 3, 64, amb_bounds_normalized );

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT( SELF, ambpanacn_data_offset ) = (t_CKINT)apacn_obj;
}


CK_DLL_CTOR( ambpanacn_ctor_order )
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT( SELF, ambpanacn_data_offset ) = 0;

    // Get constructor arguments
    t_CKINT arg1 = GET_NEXT_INT( ARGS );

    // instantiate our internal c++ class representation
    AmbPanACN * apacn_obj = new AmbPanACN( API->vm->srate(VM), arg1, 64, amb_bounds_normalized );

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT( SELF, ambpanacn_data_offset ) = (t_CKINT)apacn_obj;
}


CK_DLL_CTOR( ambpanacn_ctor_orderAndPeriod )
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT( SELF, ambpanacn_data_offset ) = 0;

    // Get constructor arguments
    t_CKINT arg1 = GET_NEXT_INT( ARGS );
    t_CKINT arg2 = GET_NEXT_INT( ARGS );

    // instantiate our internal c++ class representation
    AmbPanACN * apacn_obj = new AmbPanACN( API->vm->srate(VM), arg1, arg2, amb_bounds_normalized );

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT( SELF, ambpanacn_data_offset ) = (t_CKINT)apacn_obj;
}


CK_DLL_CTOR( ambpanacn_ctor_orderAndPeriodAndBounds )
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT( SELF, ambpanacn_data_offset ) = 0;

    // Get constructor arguments
    t_CKINT arg1 = GET_NEXT_INT( ARGS );
    t_CKINT arg2 = GET_NEXT_INT( ARGS );
    t_CKINT arg3 = GET_NEXT_INT( ARGS );

    // instantiate our internal c++ class representation
    AmbPanACN * apacn_obj = new AmbPanACN( API->vm->srate(VM), arg1, arg2, arg3 );

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT( SELF, ambpanacn_data_offset ) = (t_CKINT)apacn_obj;
}


// implementation for the destructor
CK_DLL_DTOR( ambpanacn_dtor )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE( apacn_obj );
    // set the data field to 0
    OBJ_MEMBER_INT( SELF, ambpanacn_data_offset ) = 0;
}


// implementation for tick function (relevant only for UGens)
CK_DLL_TICKF( ambpanacn_tickf )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT(SELF, ambpanacn_data_offset);

    // invoke our custom tick function
    if( apacn_obj ) apacn_obj->tick( in, out, nframes );

    // yes
    return TRUE;
}

// setters
CK_DLL_MFUN( ambpanacn_path )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );
    t_CKFLOAT arg2 = GET_NEXT_FLOAT( ARGS );
    t_CKFLOAT arg3 = GET_NEXT_FLOAT( ARGS );
    t_CKFLOAT arg4 = GET_NEXT_FLOAT( ARGS );
    t_CKFLOAT arg5 = GET_NEXT_FLOAT( ARGS );

    // call setAzimuth() and set the return value
    apacn_obj->path( arg1, arg2, arg3, arg4, arg5 );
}

// setters
CK_DLL_MFUN( ambpanacn_setAzimuth )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

    // call setAzimuth() and set the return value
    RETURN->v_float = apacn_obj->setAzimuth( arg1 );
}

// setters
CK_DLL_MFUN( ambpanacn_setAzimuthVelocity )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

    // call setAzimuth() and set the return value
    RETURN->v_float = apacn_obj->setAzimuthVelocity( arg1 );
}

CK_DLL_MFUN( ambpanacn_setElevation )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

    // call setElevation() and set the return value
    RETURN->v_float = apacn_obj->setElevation( arg1 );
}

CK_DLL_MFUN( ambpanacn_setElevationVelocity )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

    // call setElevation() and set the return value
    RETURN->v_float = apacn_obj->setElevationVelocity( arg1 );
}

CK_DLL_MFUN( ambpanacn_setVelocities )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );
    t_CKFLOAT arg2 = GET_NEXT_FLOAT( ARGS );
    

    // call setElevation() and set the return value
    RETURN->v_vec2 = apacn_obj->setVelocities( arg1, arg2 );
}

CK_DLL_MFUN( ambpanacn_set )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );
    t_CKFLOAT arg2 = GET_NEXT_FLOAT( ARGS );
    t_CKFLOAT arg3 = GET_NEXT_FLOAT( ARGS );
    t_CKFLOAT arg4 = GET_NEXT_FLOAT( ARGS );
    
    // call setElevation() and set the return value
    RETURN->v_vec4 = apacn_obj->set( arg1, arg2, arg3, arg4 );
}

CK_DLL_MFUN( ambpanacn_pan )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );
    t_CKFLOAT arg2 = GET_NEXT_FLOAT( ARGS );

    // call set() and set the return value
    RETURN->v_vec2 = apacn_obj->pan( arg1, arg2 );
}

CK_DLL_MFUN( ambpanacn_setUpdatePeriod )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_INT( ARGS );

    // call setUpdatePeriod() and set the return value
    RETURN->v_int = apacn_obj->setUpdatePeriod( arg1 );
}

CK_DLL_MFUN( ambpanacn_setOrder )
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_INT( ARGS );

    // call setUpdatePeriod() and set the return value
    RETURN->v_int = apacn_obj->setOrder( arg1 );
}

// getters
CK_DLL_MFUN(ambpanacn_getAzimuth)
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // call getAzimuth() and set the return value
    RETURN->v_float = apacn_obj->getAzimuth();
}

CK_DLL_MFUN(ambpanacn_getAzimuthVelocity)
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // call getAzimuthVelocity() and set the return value
    RETURN->v_float = apacn_obj->getAzimuthVelocity();
}

CK_DLL_MFUN(ambpanacn_getElevation)
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // call getElevation() and set the return value
    RETURN->v_float = apacn_obj->getElevation();
}

CK_DLL_MFUN(ambpanacn_getElevationVelocity)
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // call getElevationVelocity() and set the return value
    RETURN->v_float = apacn_obj->getElevationVelocity();
}

CK_DLL_MFUN(ambpanacn_getOrder)
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // call getOrder() and set the return value
    RETURN->v_int = apacn_obj->getOrder();
}

CK_DLL_MFUN(ambpanacn_getOutChannels)
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // call getOutChannels() and set the return value
    RETURN->v_int = apacn_obj->getOutChannels();
}


CK_DLL_MFUN(ambpanacn_getUpdatePeriod)
{
    // get our c++ class pointer
    AmbPanACN * apacn_obj = (AmbPanACN *)OBJ_MEMBER_INT( SELF, ambpanacn_data_offset );

    // call getUpdatePeriod() and set the return value
    RETURN->v_int = apacn_obj->getUpdatePeriod();
}
